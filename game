<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Генератор уравнений</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    /* ***********************
       Общие стили для страницы
       *********************** */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f0f0f0;
      background-image: url("https://www.gamesload.com/images/products/Microids/background__Millionaire_.jpg");
      background-repeat: no-repeat;
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
    }
    
    /* *******************************
       Стили для текстового ввода
       ******************************* */
    input[type="text"] {
      padding: 5px;
      font-size: 16px;
      width: 300px;
    }
    
    /* *******************************
       Стили для отображения уравнения
       ******************************* */
    #equation {
      font-size: 24px;
      font-weight: bold;
      margin: 20px;
      color: #333;
      min-height: 48px;
    }
    
    /* *******************************
       Стили для блока результата
       ******************************* */
    #result {
      font-size: 18px;
      margin-top: 15px;
      color: #006600;
      opacity: 1;
      min-height: 60px;
    }
    
    /* *******************************
       Стили для отображения имени пользователя
       ******************************* */
    #userDisplay {
      font-size: 20px;
      margin-bottom: 20px;
    }
    
    /* *******************************
       Стили для блока выбора сложности
       ******************************* */
    #difficultySelection {
      margin-bottom: 30px;
    }
    
    /* *******************************
       Стили для игровой области (скрыта до начала игры)
       ******************************* */
    #gameArea {
      display: none;
    }
    
    /* *******************************
       Контейнер для счётчика
       ******************************* */
    #counterContainer {
      margin-bottom: 15px;
      font-size: 18px;
    }
    
    /* *******************************
       Контейнер для таймера – отображает обратный отсчёт (например, "Время: 30 с")
       ******************************* */
    #timerDisplay {
      margin-bottom: 15px;
      font-size: 18px;
      color: #cc0000;
    }
  </style>
  <link rel="stylesheet" href="game-style.css">
</head>
<body>
  <!-- ***********************
       Заголовок страницы
       *********************** -->
  <h1>Генератор уравнений</h1>
  
  <!-- ***********************
       Отображение имени пользователя (из URL-параметра "name")
       *********************** -->
  <p id="userDisplay">Пользователь: <span id="userNameDisplay">-</span></p>
  
  <!-- ***********************
       Блок выбора сложности
       *********************** -->
  <div id="difficultySelection">
    <p>Выберите уровень сложности:</p>
    <select id="difficultySelect">
      <!-- Уровни 1–8: существующие, а теперь добавлен уровень 9 -->
      <option value="1">Уровень 1: Базовый (a*x ± b = c)</option>
      <option value="2">Уровень 2: Переменная с двух сторон (a*x ± B = d*x ± C)</option>
      <option value="3">Уровень 3: Раскрытие скобок (a*(x ± b) = c)</option>
      <option value="4">Уровень 4: Дробный коэффициент (1/d*x ± b = c)</option>
      <option value="5">Уровень 5: Расширенное уравнение (a*(x ± b) ± c = d*(x ± e) ± f)</option>
      <option value="6">Уровень 6: Системное уравнение (две переменные: x и y)</option>
      <option value="7">Уровень 7: Дробное уравнение ((x ± a)/b = c)</option>
      <option value="8">Уровень 8: Квадратное уравнение (a*x² + b*x + c = 0)</option>
      <option value="9">Уровень 9: Уравнение со скобками ((ax+b)(cx+d) = (ex+f)(gx+h))</option>
    </select>
    <br><br>
    <button id="startGameBtn">Начать игру</button>
  </div>
  
  <!-- ***********************
       Игровая область
       *********************** -->
  <div id="gameArea">
    <p id="counterContainer">Счётчик: <span id="counter">10</span></p>
    <p id="timerDisplay">Время: 30 с</p>
    <p id="equation"></p>
    <input type="text" id="answer" placeholder="Введите значение">
    <p id="result"></p>
  </div>
  <script>
    // ====================================================
    // 1. Глобальные переменные и извлечение параметров из URL
    // ====================================================
    let currentDifficulty = 1;
    let currentSolution = null;
    let questionStartTime = null;
    let counter = 10;
    let timerInterval = null;  // Интервал таймера
    let currentTime = 0;       // Оставшееся время таймера (сек)
    let timedOut = false;      // Флаг, что для текущего уравнения таймер сработал
    
    const urlParams = new URLSearchParams(window.location.search);
    
    // Параметр "counter"
    const counterParam = urlParams.get('counter');
    if (counterParam !== null) {
      const initialCounter = parseInt(counterParam, 10);
      if (!isNaN(initialCounter)) { counter = initialCounter; }
    }
    
    // Параметр "penalty" – штраф за неправильный ответ
    let penalty = 2;
    const penaltyParam = urlParams.get('penalty');
    if (penaltyParam !== null) {
      const parsedPenalty = parseInt(penaltyParam, 10);
      if (!isNaN(parsedPenalty)) { penalty = parsedPenalty; }
    }
    
    // Параметр "timeLimit" – продолжительность таймера (сек; по умолчанию 30)
    let timeLimit = 30;
    const timeLimitParam = urlParams.get('timeLimit');
    if (timeLimitParam !== null) {
      const tl = parseInt(timeLimitParam, 10);
      if (!isNaN(tl)) { timeLimit = tl; }
    }
    
    // Параметр "timePunishment" – штраф за истечение времени (сек; по умолчанию 1)
    let timePunishment = 1;
    const timePunishmentParam = urlParams.get('timePunishment');
    if (timePunishmentParam !== null) {
      const tp = parseInt(timePunishmentParam, 10);
      if (!isNaN(tp)) { timePunishment = tp; }
    }
    
    // Параметр "name"
    let userName = urlParams.get('name');
    if (!userName) { userName = "-"; }
    document.getElementById("userNameDisplay").textContent = userName;
    
    // Режим тестера: если в URL есть tester=true, скрыть таймер и счётчик
    let testerMode = (urlParams.get("tester") || "").toLowerCase() === "true";
    if (testerMode) {
      const counterContainer = document.getElementById("counterContainer");
      if (counterContainer) { counterContainer.style.display = "none"; }
      document.getElementById("timerDisplay").style.display = "none";
    }
    
    // ====================================================
    // 2. Массивы для статистики и получение элементов документа
    // ====================================================
    let correctTimes = [];
    let incorrectTimes = [];
    let completedEquations = [];
    
    const equationP = document.getElementById("equation");
    const answerInput = document.getElementById("answer");
    const resultP = document.getElementById("result");
    const counterSpan = document.getElementById("counter");
    const timerDisplay = document.getElementById("timerDisplay");
    const difficultySelect = document.getElementById("difficultySelect");
    const startGameBtn = document.getElementById("startGameBtn");
    const difficultySelectionDiv = document.getElementById("difficultySelection");
    const gameAreaDiv = document.getElementById("gameArea");
    
    // Функция обновления счётчика
    function updateCounter() {
      if (!testerMode) { counterSpan.textContent = counter; }
    }
    updateCounter();
    
    // Функция обновления отображения таймера
    function updateTimerDisplay() {
      if (!testerMode) { timerDisplay.textContent = "Время: " + currentTime + " с"; }
    }
    updateTimerDisplay();
    
    // ====================================================
    // 3. Вспомогательные функции форматирования
    // ====================================================
    function formatVarTerm(coefficient, variable) {
      return (Math.abs(coefficient) === 1) ? variable : (coefficient + variable);
    }
    function formatConstTerm(value) {
      return (value >= 0) ? value.toString() : "-" + Math.abs(value).toString();
    }
    
    // Функция получения строки с правильным ответом
    function getCorrectAnswer(solution) {
      if (solution === null) return "";
      if (typeof solution === "object") {
        if (solution.hasOwnProperty("x") && solution.hasOwnProperty("y")) {
          return "x: " + solution.x + ", y: " + solution.y;
        } else if (Array.isArray(solution)) {
          return solution.join(", ");
        }
      }
      return solution.toString();
    }
  </script>
  <script>
    // ====================================================
    // 4. Функция генерации уравнений по уровню сложности
    // ====================================================
    function generateRandomEquationByDifficulty(difficulty) {
      let eqObj = { equation: "", solution: null };
      
      if (difficulty === 1) {
        let a, xSolution, b, c;
        do {
          a = Math.floor(Math.random() * 9) + 2;
          if (Math.random() < 0.5) { a = -a; }
          xSolution = Math.floor(Math.random() * 11);
          b = (Math.random() < 0.5) ? Math.floor(Math.random() * 20) + 1
                                    : - (Math.floor(Math.random() * 20) + 1);
          c = a * xSolution + b;
        } while (b === 0 || Math.abs(b) === Math.abs(a) ||
                 Math.abs(a) === 1 || Math.abs(c) === Math.abs(a) ||
                 Math.abs(c) === Math.abs(b) || Math.abs(c) === xSolution);
        let termVar = formatVarTerm(a, "x");
        let left = (Math.random() < 0.5)
          ? (formatConstTerm(b) + " + " + termVar)
          : (termVar + (b >= 0 ? " + " + b : " - " + Math.abs(b)));
        eqObj.equation = left + " = " + c;
        eqObj.solution = xSolution;
      
      } else if (difficulty === 2) {
        let a, d, xSolution, B, C;
        do {
          a = Math.floor(Math.random() * 9) + 2;
          if (Math.random() < 0.5) { a = -a; }
          do { d = Math.floor(Math.random() * 9) + 2; if (Math.random() < 0.5) { d = -d; } }
          while (Math.abs(d) === Math.abs(a));
          xSolution = Math.floor(Math.random() * 11);
          B = (Math.random() < 0.5) ? Math.floor(Math.random() * 21) : -Math.floor(Math.random() * 21);
          C = (a - d) * xSolution + B;
        } while (B === 0 || Math.abs(B) === Math.abs(a) ||
                 Math.abs(a) === 1 || Math.abs(d) === 1 ||
                 Math.abs(a) === xSolution || Math.abs(d) === xSolution ||
                 Math.abs(B) === xSolution || Math.abs(C) === xSolution);
        let leftTermVar = formatVarTerm(a, "x");
        let rightTermVar = formatVarTerm(d, "x");
        let leftSide = (Math.random() < 0.5)
          ? (formatConstTerm(B) + " + " + leftTermVar)
          : (leftTermVar + (B === 0 ? "" : (B >= 0 ? " + " + B : " - " + Math.abs(B))));
        let rightSide = (Math.random() < 0.5)
          ? (formatConstTerm(C) + " + " + rightTermVar)
          : (rightTermVar + (C === 0 ? "" : (C >= 0 ? " + " + C : " - " + Math.abs(C))));
        eqObj.equation = leftSide + " = " + rightSide;
        eqObj.solution = xSolution;
      
      } else if (difficulty === 3) {
        let a, xSolution, b, c;
        do {
          a = Math.floor(Math.random() * 9) + 2;
          if (Math.random() < 0.5) { a = -a; }
          xSolution = Math.floor(Math.random() * 11);
          b = (Math.random() < 0.5)
              ? Math.floor(Math.random() * 21)
              : -Math.floor(Math.random() * 21);
          c = a * (xSolution + b);
        } while (b === 0 || Math.abs(b) === Math.abs(a) ||
                 Math.abs(a) === 1 || Math.abs(a) === xSolution || Math.abs(b) === xSolution);
        let normalInner = (b === 0) ? "x" : (b > 0 ? "x + " + b : "x - " + Math.abs(b));
        let swappedInner = (b === 0) ? "x" : (formatConstTerm(b) + " + x");
        let inner = (Math.random() < 0.5) ? swappedInner : normalInner;
        let aStr = (Math.abs(a) === 1) ? "" : a.toString();
        eqObj.equation = aStr + "(" + inner + ") = " + c;
        eqObj.solution = xSolution;
      
      } else if (difficulty === 4) {
        let d, k, xSolution, b, c;
        d = Math.floor(Math.random() * 8) + 2;
        if (Math.random() < 0.5) { d = -d; }
        k = Math.floor(Math.random() * 11) - 5;
        xSolution = d * k;
        do {
          b = (Math.random() < 0.5)
              ? Math.floor(Math.random() * 21)
              : -Math.floor(Math.random() * 21);
        } while (b === 0 || Math.abs(b) === Math.abs(xSolution));
        c = k + b;
        let baseStr = "1/" + d + "x";
        let normalLeft = baseStr + (b === 0 ? "" : (b >= 0 ? " + " + b : " - " + Math.abs(b)));
        let swappedLeft = (b === 0) ? baseStr : (formatConstTerm(b) + " + " + baseStr);
        let left = (Math.random() < 0.5) ? swappedLeft : normalLeft;
        eqObj.equation = left + " = " + c;
        eqObj.solution = xSolution;
      
      } else if (difficulty === 5) {
        // Новый вариант для уравнения вида: a*(x ± b) ± c = d*(x ± e) ± f,
        // чтобы решение уравнения было точно равно xSolution.
        // Генерируем a и d, где a и d не равны по модулю.
        let a = Math.floor(Math.random() * 8) + 2;
        if (Math.random() < 0.5) { a = -a; }
        let d;
        do {
          d = Math.floor(Math.random() * 8) + 2;
          if (Math.random() < 0.5) { d = -d; }
        } while (Math.abs(d) === Math.abs(a));
        let s1 = (Math.random() < 0.5) ? 1 : -1;
        let s2 = (Math.random() < 0.5) ? 1 : -1;
        let b = Math.floor(Math.random() * 15) + 1;
        let e = Math.floor(Math.random() * 15) + 1;
        let xSolution = (Math.floor(Math.random() * 41) - 20) / 2;
        let c;
        do {
          c = Math.floor(Math.random() * 41) - 20;
        } while (c === 0);
        let f = a * (xSolution + s1 * b) + c - d * (xSolution + s2 * e);
        let leftExpr = (Math.abs(a) === 1 ? "" : a.toString()) + "(x " + (s1 === -1 ? "- " : "+ ") + b + ")"
                     + (c >= 0 ? " + " + c : " - " + Math.abs(c));
        let rightExpr = (Math.abs(d) === 1 ? "" : d.toString()) + "(x " + (s2 === -1 ? "- " : "+ ") + e + ")"
                     + (f >= 0 ? " + " + f : " - " + Math.abs(f));
        eqObj.equation = leftExpr + " = " + rightExpr;
        eqObj.solution = xSolution; 
      
      } else if (difficulty === 6) {
        let xSolution = Math.floor(Math.random() * 21) - 10;
        let ySolution = Math.floor(Math.random() * 21) - 10;
        let a1, b1, a2, b2;
        do {
          a1 = Math.floor(Math.random() * 9) + 2;
          if (Math.random() < 0.5) { a1 = -a1; }
          b1 = Math.floor(Math.random() * 21) - 10;
          a2 = Math.floor(Math.random() * 9) + 2;
          if (Math.random() < 0.5) { a2 = -a2; }
          b2 = Math.floor(Math.random() * 21) - 10;
        } while (a1 * b2 - a2 * b1 === 0);
        let c1 = a1 * xSolution + b1 * ySolution;
        let c2 = a2 * xSolution + b2 * ySolution;
        function formatTerm(coefficient, variable) {
          if (coefficient === 1) return variable;
          if (coefficient === -1) return "-" + variable;
          return coefficient + variable;
        }
        let eq1 = formatTerm(a1, "x") + (b1 >= 0 ? " + " + b1 + "y" : " - " + Math.abs(b1) + "y") + " = " + c1;
        let eq2 = formatTerm(a2, "x") + (b2 >= 0 ? " + " + b2 + "y" : " - " + Math.abs(b2) + "y") + " = " + c2;
        eqObj.equation = eq1 + "<br>" + eq2;
        eqObj.solution = { x: xSolution, y: ySolution };
      
      } else if (difficulty === 7) {
        let b;
        do { b = Math.floor(Math.random() * 21) - 10; } while (b === 0);
        let a = Math.floor(Math.random() * 21) - 10;
        let c = Math.floor(Math.random() * 21) - 10;
        let xSolution = c * b - a;
        let inner;
        if (a === 0) { inner = "x"; }
        else if (a > 0) { inner = "x + " + a; }
        else { inner = "x - " + Math.abs(a); }
        eqObj.equation = "(" + inner + ")/" + b + " = " + c;
        eqObj.solution = xSolution;
      
      } else if (difficulty === 8) {
        let a = Math.floor(Math.random() * 9) + 1;
        let r1 = Math.floor(Math.random() * 21) - 10;
        let r2 = Math.floor(Math.random() * 21) - 10;
        let bCoeff = -a * (r1 + r2);
        let cCoeff = a * r1 * r2;
        function formatCoeff(coefficient, variable, isFirst) {
          if (coefficient === 0) return "";
          if (isFirst) {
            if (coefficient === 1) return variable;
            if (coefficient === -1) return "-" + variable;
            return coefficient + variable;
          } else {
            if (coefficient > 0) {
              if (coefficient === 1) return " + " + variable;
              return " + " + coefficient + variable;
            } else {
              if (coefficient === -1) return " - " + variable;
              return " - " + Math.abs(coefficient) + variable;
            }
          }
        }
        let eqStr = "";
        eqStr += (a === 1) ? "x²" : a + "x²";
        eqStr += formatCoeff(bCoeff, "x", false);
        if (cCoeff > 0) { eqStr += " + " + cCoeff; }
        else if (cCoeff < 0) { eqStr += " - " + Math.abs(cCoeff); }
        eqStr += " = 0";
        eqObj.equation = eqStr;
        eqObj.solution = (r1 === r2) ? [r1] : [r1, r2];
      
      } else if (difficulty === 9) {
        // Уровень 9: (ax+b)(cx+d) = (ex+f)(gx+h)
        // Если нет действительных корней, решение становится 0.
        let a, b, c, d, e, f, g, h, A, B, C, disc;
        let attempts = 0, maxAttempts = 1000;
        while (attempts < maxAttempts) {
          attempts++;
          a = Math.floor(Math.random() * 5) + 2;
          if (Math.random() < 0.5) a = -a;
          b = Math.floor(Math.random() * 11) - 5;
          if (b === 0) b = 2;
          c = Math.floor(Math.random() * 5) + 2;
          if (Math.random() < 0.5) c = -c;
          d = Math.floor(Math.random() * 11) - 5;
          if (d === 0) d = 3;
  
          e = Math.floor(Math.random() * 5) + 2;
          if (Math.random() < 0.5) e = -e;
          f = Math.floor(Math.random() * 11) - 5;
          if (f === 0) f = 2;
          g = Math.floor(Math.random() * 5) + 2;
          if (Math.random() < 0.5) g = -g;
          h = Math.floor(Math.random() * 11) - 5;
          if (h === 0) h = 3;
  
          A = a * c - e * g;
          B = (a * d + b * c) - (e * h + f * g);
          C = b * d - f * h;
          if (A === 0) continue;
          disc = B * B - 4 * A * C;
          break;
        }
        if (attempts === maxAttempts) {
          a = 2; b = 3; c = 3; d = 4; e = 2; f = 1; g = 4; h = 3;
          A = a * c - e * g;
          B = (a * d + b * c) - (e * h + f * g);
          C = b * d - f * h;
          disc = B * B - 4 * A * C;
        }
        eqObj.equation =
          "(" + a + "x " + (b >= 0 ? "+ " + b : "- " + Math.abs(b)) + ")" +
          "(" + c + "x " + (d >= 0 ? "+ " + d : "- " + Math.abs(d)) + ")" +
          " = (" + e + "x " + (f >= 0 ? "+ " + f : "- " + Math.abs(f)) + ")" +
          "(" + g + "x " + (h >= 0 ? "+ " + h : "- " + Math.abs(h)) + ")";
        if (disc < 0) {
          eqObj.solution = 0;
        } else {
          let sqrtDisc = Math.sqrt(disc);
          let num1 = -B + sqrtDisc;
          let num2 = -B - sqrtDisc;
          let den = 2 * A;
          
          function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
              let temp = b;
              b = a % b;
              a = temp;
            }
            return a;
          }
          
          if (sqrtDisc % 1 === 0) {
            // Рациональные корни, представляем в виде сокращенной дроби.
            function toFraction(numer, denom) {
              let g = gcd(numer, denom);
              numer = numer / g;
              denom = denom / g;
              if (denom < 0) {
                numer = -numer;
                denom = -denom;
              }
              return (denom === 1) ? `${numer}` : `${numer}/${denom}`;
            }
            let frac1 = toFraction(num1, den);
            let frac2 = toFraction(num2, den);
            if (frac1 === frac2) {
              eqObj.solution = [frac1];
            } else {
              eqObj.solution = [frac1, frac2];
            }
          } else {
            // Иррациональные корни, округляем до двух знаков после запятой.
            let root1 = Number((num1 / den).toFixed(2));
            let root2 = Number((num2 / den).toFixed(2));
            if (Math.abs(root1 - root2) < 0.001) {
              eqObj.solution = [root1];
            } else {
              eqObj.solution = [root1, root2];
            }
          }
        }
      }
      
      return eqObj;
    }
    
    // ====================================================
    // 5. Функция генерации и отображения нового уравнения, а также запуск таймера
    // ====================================================
    function generateEquation() {
      answerInput.value = "";
      answerInput.disabled = false;
      answerInput.focus();
      
      clearInterval(timerInterval);
      currentTime = timeLimit;
      updateTimerDisplay();
      timedOut = false;
      
      const randomEq = generateRandomEquationByDifficulty(currentDifficulty);
      
      // Отобразить уравнение и задать placeholder в зависимости от сложности
      if (currentDifficulty === 6) {
        equationP.innerHTML = randomEq.equation;
        answerInput.placeholder = testerMode ? "Правильный ответ: " + getCorrectAnswer(randomEq.solution) : "Введите x и y через запятую";
      } else if (currentDifficulty === 8) {
        equationP.textContent = randomEq.equation;
        answerInput.placeholder = testerMode ? "Правильный ответ: " + getCorrectAnswer(randomEq.solution) : "Введите корни через запятую";
      } else if (currentDifficulty === 9) {
        equationP.textContent = randomEq.equation;
        answerInput.placeholder = testerMode ? "Правильный ответ: " + getCorrectAnswer(randomEq.solution) : "Введите ответы через запятую (в виде дробей)";
      } else {
        equationP.textContent = randomEq.equation;
        answerInput.placeholder = testerMode ? "Правильный ответ: " + getCorrectAnswer(randomEq.solution) : "Введите значение";
      }
      
      currentSolution = randomEq.solution;
      questionStartTime = Date.now();
      
      if (!testerMode) {
        timerInterval = setInterval(function() {
          currentTime--;
          updateTimerDisplay();
          if (currentTime <= 0 && !timedOut) {
            timedOut = true;
            clearInterval(timerInterval);
            counter += timePunishment;
            updateCounter();
            resultP.textContent = "Время истекло! + " + timePunishment;
          }
        }, 1000);
      }
    }
    
    // ====================================================
    // 6. Функция вычисления статистики (лучшее, худшее, среднее время)
    // ====================================================
    function computeStats(times) {
      if (times.length === 0) { return { best: "-", worst: "-", average: "-" }; }
      const best = Math.min(...times);
      const worst = Math.max(...times);
      const sum = times.reduce((acc, t) => acc + t, 0);
      const average = sum / times.length;
      return { best: best.toFixed(2), worst: worst.toFixed(2), average: average.toFixed(2) };
    }
    
    // ====================================================
    // 7. Функция отправки статистики на сервер (с уровнями и именем)
    // ====================================================
    function sendStats(correctStats, incorrectStats, correctCount, incorrectCount, history) {
      const formData = new URLSearchParams();
      formData.append('difficulty', currentDifficulty);
      formData.append('best_correct', correctStats.best);
      formData.append('worst_correct', correctStats.worst);
      formData.append('avg_correct', correctStats.average);
      formData.append('best_incorrect', incorrectStats.best);
      formData.append('worst_incorrect', incorrectStats.worst);
      formData.append('avg_incorrect', incorrectStats.average);
      formData.append('correct_count', correctCount);
      formData.append('incorrect_count', incorrectCount);
      formData.append('history', history.join(", "));
      formData.append('name', userName);
      
      fetch('save_stats.php', {
        method: 'POST',
        body: formData
      })
      .then(response => response.text())
      .then(text => { console.log("Ответ сервера: " + text); })
      .catch(error => { console.error("Ошибка отправки данных: " + error); });
    }
    
    // ====================================================
    // 8. Функция завершения игры: вывод статистики и отправка данных
    // ====================================================
    function endGame() {
      const correctStats = computeStats(correctTimes);
      const incorrectStats = computeStats(incorrectTimes);
      let historyTimes = completedEquations.map(item => Math.round(item.time));
      
      let outputHTML =
        `<h2>Игра окончена</h2>
         <h3>Правильные ответы (кол-во: ${correctTimes.length}):</h3>
         <p>Лучшее время: ${correctStats.best} сек</p>
         <p>Худшее время: ${correctStats.worst} сек</p>
         <p>Среднее время: ${correctStats.average} сек</p>
         <h3>Неправильные ответы (кол-во: ${incorrectTimes.length}):</h3>
         <p>Лучшее время: ${incorrectStats.best} сек</p>
         <p>Худшее время: ${incorrectStats.worst} сек</p>
         <p>Среднее время: ${incorrectStats.average} сек</p>
         <h3>История времени решений (сек):</h3>
         <p>${historyTimes.join(", ")}</p>`;
      
      resultP.innerHTML = outputHTML;
      answerInput.disabled = true;
      
      if (!testerMode) { sendStats(correctStats, incorrectStats, correctTimes.length, incorrectTimes.length, historyTimes); }
    }
    
    // ====================================================
    // 9. Функция проверки ответа пользователя
    // ====================================================
    function checkAnswer() {
      if (testerMode) {
        resultP.textContent = "Режим тестера активен. Пропуск проверки ответа.";
        setTimeout(() => { resultP.textContent = ""; generateEquation(); }, 1500);
        return;
      }
      
      if (currentSolution === null) {
        resultP.textContent = "Подождите, уравнение ещё не загрузилось!";
        return;
      }
      
      const responseTime = (Date.now() - questionStartTime) / 1000;
      
      if (currentDifficulty === 6) {
        let userInput = answerInput.value.split(",");
        if (userInput.length !== 2) {
          resultP.textContent = "Пожалуйста, введите два числовых значения через запятую.";
          return;
        }
        let userX = parseFloat(userInput[0].trim());
        let userY = parseFloat(userInput[1].trim());
        if (isNaN(userX) || isNaN(userY)) {
          resultP.textContent = "Пожалуйста, введите корректные числовые значения.";
          return;
        }
        if (Math.abs(userX - currentSolution.x) < 0.001 &&
            Math.abs(userY - currentSolution.y) < 0.001) {
          clearInterval(timerInterval);
          resultP.textContent = "Верно!";
          correctTimes.push(responseTime);
          completedEquations.push({ equation: equationP.innerHTML, time: responseTime });
          if (!testerMode && !timedOut) {
            counter--;
            updateCounter();
          }
          answerInput.disabled = true;
          if (!testerMode && counter <= 0) {
            setTimeout(() => {
              resultP.style.transition = "opacity 2s";
              resultP.style.opacity = "0";
              setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; endGame(); }, 2000);
            }, 2000);
            return;
          }
          setTimeout(() => {
            resultP.style.transition = "opacity 2s";
            resultP.style.opacity = "0";
            setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; generateEquation(); }, 2000);
          }, 2000);
        } else {
          resultP.textContent = "Неправильно! Попробуйте ещё.";
          incorrectTimes.push(responseTime);
          if (!testerMode) { counter += penalty; updateCounter(); }
          answerInput.value = "";
          setTimeout(() => { resultP.textContent = ""; }, 1000);
        }
      
      } else if (currentDifficulty === 8) {
        let parts = answerInput.value.split(",");
        let userRoots = parts.map(p => parseFloat(p.trim())).filter(v => !isNaN(v));
        let solutionArray = currentSolution;
        if (solutionArray.length === 1 && userRoots.length !== 1) {
          resultP.textContent = "Уравнение имеет один корень. Введите одно число.";
          return;
        }
        if (solutionArray.length === 2 && userRoots.length !== 2) {
          resultP.textContent = "Уравнение имеет два корня. Введите два числа через запятую.";
          return;
        }
        if (solutionArray.length === 2) {
          userRoots.sort((a, b) => a - b);
          let sortedSolution = solutionArray.slice().sort((a, b) => a - b);
          if (Math.abs(userRoots[0] - sortedSolution[0]) < 0.001 &&
              Math.abs(userRoots[1] - sortedSolution[1]) < 0.001) {
            clearInterval(timerInterval);
            resultP.textContent = "Верно!";
            correctTimes.push(responseTime);
            completedEquations.push({ equation: equationP.textContent, time: responseTime });
            if (!testerMode && !timedOut) {
              counter--;
              updateCounter();
            }
            answerInput.disabled = true;
            if (!testerMode && counter <= 0) {
              setTimeout(() => {
                resultP.style.transition = "opacity 2s";
                resultP.style.opacity = "0";
                setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; endGame(); }, 2000);
              }, 2000);
              return;
            }
            setTimeout(() => {
              resultP.style.transition = "opacity 2s";
              resultP.style.opacity = "0";
              setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; generateEquation(); }, 2000);
            }, 2000);
          } else {
            resultP.textContent = "Неправильно! Попробуйте ещё.";
            incorrectTimes.push(responseTime);
            if (!testerMode) { counter += penalty; updateCounter(); }
            answerInput.value = "";
            setTimeout(() => { resultP.textContent = ""; }, 1000);
          }
        } else {
          if (userAnswers.length !== 1) {
            resultP.textContent = "Ожидается один ответ.";
            return;
          }
          let userAnswer = userAnswers[0];
          if (Math.abs(userAnswer - currentSolution) < 0.001) {
            clearInterval(timerInterval);
            resultP.textContent = "Верно!";
            correctTimes.push(responseTime);
            completedEquations.push({ equation: equationP.textContent, time: responseTime });
            if (!testerMode && !timedOut) {
              counter--;
              updateCounter();
            }
            answerInput.disabled = true;
            if (!testerMode && counter <= 0) {
              setTimeout(() => {
                resultP.style.transition = "opacity 2s";
                resultP.style.opacity = "0";
                setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; endGame(); }, 2000);
              }, 2000);
              return;
            }
            setTimeout(() => {
              resultP.style.transition = "opacity 2s";
              resultP.style.opacity = "0";
              setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; generateEquation(); }, 2000);
            }, 2000);
          } else {
            resultP.textContent = "Неправильно! Попробуйте ещё.";
            incorrectTimes.push(responseTime);
            if (!testerMode) { counter += penalty; updateCounter(); }
            answerInput.value = "";
            setTimeout(() => { resultP.textContent = ""; }, 1000);
          }
        }
      
      } else if (currentDifficulty === 9) {
        // В ответе пользователя ожидается ввод дроби (например "1/3" или "2/5"), разделённых запятыми
        let userInput = answerInput.value.split(",").map(item => item.trim()).filter(item => item !== "");
        // Функция для приведения дроби к числовому значению
        function fractionToNumber(frac) {
          if (frac.includes("/")) {
            let parts = frac.split("/");
            if (parts.length === 2) {
              let num = parseFloat(parts[0]);
              let den = parseFloat(parts[1]);
              if (!isNaN(num) && !isNaN(den) && den !== 0) {
                return num / den;
              }
            }
          }
          // Если не дробь, пробуем как число
          return parseFloat(frac.replace(",", "."));
        }
        let userAnswers = userInput.map(fractionToNumber).filter(n => !isNaN(n));
  
        if (Array.isArray(currentSolution)) {
          // Для проверки, преобразуем каждую дробь в число
          let sortedUser = [...userAnswers].sort((a, b) => a - b);
          // Для рациональных корней, сравнение производится по числовому значению
          let sortedSolution = currentSolution.map(frac => {
            if (typeof frac === "string" && frac.includes("/")) {
              let parts = frac.split("/");
              return parseFloat(parts[0]) / parseFloat(parts[1]);
            }
            return frac;
          }).sort((a, b) => a - b);
          let correct = sortedUser.length === sortedSolution.length &&
                        sortedUser.every((val, i) => Math.abs(val - sortedSolution[i]) < 0.001);
          if (correct) {
            clearInterval(timerInterval);
            resultP.textContent = "Верно!";
            correctTimes.push(responseTime);
            completedEquations.push({ equation: equationP.textContent, time: responseTime });
            if (!testerMode && !timedOut) {
              counter--;
              updateCounter();
            }
            answerInput.disabled = true;
            if (!testerMode && counter <= 0) {
              setTimeout(() => {
                resultP.style.transition = "opacity 2s";
                resultP.style.opacity = "0";
                setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; endGame(); }, 2000);
              }, 2000);
              return;
            }
            setTimeout(() => {
              resultP.style.transition = "opacity 2s";
              resultP.style.opacity = "0";
              setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; generateEquation(); }, 2000);
            }, 2000);
          } else {
            resultP.textContent = "Неправильно! Попробуйте ещё.";
            incorrectTimes.push(responseTime);
            if (!testerMode) { counter += penalty; updateCounter(); }
            answerInput.value = "";
            setTimeout(() => { resultP.textContent = ""; }, 1000);
          }
        } else {
          if (userAnswers.length !== 1) {
            resultP.textContent = "Ожидается один ответ.";
            return;
          }
          let userAnswer = userAnswers[0];
          if (Math.abs(userAnswer - currentSolution) < 0.001) {
            clearInterval(timerInterval);
            resultP.textContent = "Верно!";
            correctTimes.push(responseTime);
            completedEquations.push({ equation: equationP.textContent, time: responseTime });
            if (!testerMode && !timedOut) {
              counter--;
              updateCounter();
            }
            answerInput.disabled = true;
            if (!testerMode && counter <= 0) {
              setTimeout(() => {
                resultP.style.transition = "opacity 2s";
                resultP.style.opacity = "0";
                setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; endGame(); }, 2000);
              }, 2000);
              return;
            }
            setTimeout(() => {
              resultP.style.transition = "opacity 2s";
              resultP.style.opacity = "0";
              setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; generateEquation(); }, 2000);
            }, 2000);
          } else {
            resultP.textContent = "Неправильно! Попробуйте ещё.";
            incorrectTimes.push(responseTime);
            if (!testerMode) { counter += penalty; updateCounter(); }
            answerInput.value = "";
            setTimeout(() => { resultP.textContent = ""; }, 1000);
          }
        }
      
      } else {
        let userAnswer = parseFloat(answerInput.value);
        if (isNaN(userAnswer)) {
          resultP.textContent = "Пожалуйста, введите числовое значение.";
          return;
        }
        if (Math.abs(userAnswer - currentSolution) < 0.001) {
          clearInterval(timerInterval);
          resultP.textContent = "Верно!";
          correctTimes.push(responseTime);
          completedEquations.push({ equation: equationP.textContent, time: responseTime });
          if (!testerMode && !timedOut) {
            counter--;
            updateCounter();
          }
          answerInput.disabled = true;
          if (!testerMode && counter <= 0) {
            setTimeout(() => {
              resultP.style.transition = "opacity 2s";
              resultP.style.opacity = "0";
              setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; endGame(); }, 2000);
            }, 2000);
            return;
          }
          setTimeout(() => {
            resultP.style.transition = "opacity 2s";
            resultP.style.opacity = "0";
            setTimeout(() => { resultP.textContent = ""; resultP.style.opacity = "1"; generateEquation(); }, 2000);
          }, 2000);
        } else {
          resultP.textContent = "Неправильно! Попробуйте ещё.";
          incorrectTimes.push(responseTime);
          if (!testerMode) { counter += penalty; updateCounter(); }
          answerInput.value = "";
          setTimeout(() => { resultP.textContent = ""; }, 1000);
        }
      }
    }
    
    // ====================================================
    // 10. Обработчик клавиши Enter для проверки ответа
    // ====================================================
    answerInput.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        checkAnswer();
      }
    });
    
    // ====================================================
    // 11. Обработчик кнопки "Начать игру"
    // ====================================================
    startGameBtn.addEventListener("click", function() {
      currentDifficulty = parseInt(difficultySelect.value, 10);
      difficultySelectionDiv.style.display = "none";
      gameAreaDiv.style.display = "block";
      answerInput.focus();
      generateEquation();
    });
    
  </script>
</body>
</html>
